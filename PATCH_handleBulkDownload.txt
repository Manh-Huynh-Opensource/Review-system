// Patch for handleBulkDownload function
// Replace lines 266-353 in DashboardPage.tsx

const handleBulkDownload = async (filesToDownload: FileWithProject[]) => {
    if (filesToDownload.length === 0) return

    try {
        const zip = new JSZip()
        toast.success(`Đang chuẩn bị ${filesToDownload.length} files...`)

        let successCount = 0
        let errorCount = 0

        // Helper to get file extension
        const getFileExtension = (url: string, mimeType?: string): string => {
            const urlMatch = url.match(/\.[^./?#]+(?=[?#]|$)/)
            if (urlMatch) return urlMatch[0]
            if (mimeType) {
                const ext = mimeType.split('/')[1]
                return `.${ext.replace('jpeg', 'jpg')}`
            }
            return ''
        }

        for (const file of filesToDownload) {
            const currentVersion = file.versions.find(v => v.version === file.currentVersion)
            if (!currentVersion?.url) {
                console.warn(`No URL found for file: ${file.name}`)
                errorCount++
                continue
            }

            try {
                // For sequences, download all frames
                if (file.type === 'sequence' && file.sequenceUrls && file.sequenceUrls.length > 0) {
                    const folderName = file.name.replace(/\.[^/.]+$/, '') || file.name
                    const folder = zip.folder(folderName)
                    if (!folder) {
                        errorCount++
                        continue
                    }

                    // Add all sequence frames
                    for (let i = 0; i < file.sequenceUrls.length; i++) {
                        try {
                            const frameResponse = await fetch(file.sequenceUrls[i])
                            if (frameResponse.ok) {
                                const frameBlob = await frameResponse.blob()
                                const ext = getFileExtension(file.sequenceUrls[i], frameBlob.type)
                                const frameName = `frame_${String(i + 1).padStart(4, '0')}${ext || '.jpg'}`
                                folder.file(frameName, frameBlob)
                            }
                        } catch (err) {
                            console.error(`Error fetching frame ${i}:`, err)
                        }
                    }

                    // Add comments for sequence
                    const fileComments = comments.filter(c => c.fileId === file.id)
                    if (fileComments.length > 0) {
                        const commentsText = fileComments.map(c => {
                            const date = c.timestamp?.toDate?.() || new Date(c.timestamp)
                            return `[${c.isResolved ? 'RESOLVED' : 'PENDING'}] ${c.author} (${date.toLocaleString('vi-VN')}):\n${c.text}\n${c.annotationData ? `Frame: ${c.annotationData.frameIndex || 0}` : ''}\n`
                        }).join('\n---\n\n')
                        folder.file('comments.txt', commentsText)
                    }

                    successCount++
                } else {
                    // Single file download
                    const response = await fetch(currentVersion.url)
                    if (!response.ok) throw new Error(`Failed to fetch ${file.name}`)
                    
                    const blob = await response.blob()
                    
                    // Ensure file has extension
                    let fileName = file.name
                    if (!fileName.includes('.')) {
                        const ext = getFileExtension(currentVersion.url, blob.type)
                        fileName = `${fileName}${ext}`
                    }
                    
                    zip.file(fileName, blob)

                    // Add comments for single file
                    const fileComments = comments.filter(c => c.fileId === file.id)
                    if (fileComments.length > 0) {
                        const commentsText = fileComments.map(c => {
                            const date = c.timestamp?.toDate?.() || new Date(c.timestamp)
                            return `[${c.isResolved ? 'RESOLVED' : 'PENDING'}] ${c.author} (${date.toLocaleString('vi-VN')}):\n${c.text}\n${c.annotationData ? `Annotation: ${c.annotationData.type || 'N/A'}` : ''}\n`
                        }).join('\n---\n\n')
                        
                        const commentFileName = fileName.replace(/\.[^/.]+$/, '') + '_comments.txt'
                        zip.file(commentFileName, commentsText)
                    }

                    successCount++
                }
            } catch (error) {
                console.error(`Error downloading file ${file.name}:`, error)
                errorCount++
            }
        }

        if (successCount === 0) {
            toast.error('Không thể tải xuống files')
            return
        }

        // Generate ZIP file
        toast.success('Đang nén files...')
        const zipBlob = await zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        })

        // Download ZIP
        const timestamp = new Date().toISOString().split('T')[0]
        const filename = `files-download-${timestamp}.zip`
        
        const link = document.createElement('a')
        link.href = URL.createObjectURL(zipBlob)
        link.download = filename
        document.body.appendChild(link)
        link.click()
        document.body.removeChild(link)
        URL.revokeObjectURL(link.href)

        toast.success(`Đã tải xuống ${successCount} files${errorCount > 0 ? ` (${errorCount} lỗi)` : ''}`)
    } catch (error) {
        console.error('Bulk download error:', error)
        toast.error('Lỗi khi tải files')
    }
}
